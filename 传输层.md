### 传输层定义与功能  
> ![image1](https://github.com/onshero/PCN/blob/picture/传输层.png)  
> （1）定义  
>> Transport Layer也称为运输层。在OSI中，传输层利用网络层提供的服务，并通过传输层地址提供给高层用户传输数据的通信端口，使系统间高层资源的共享不必考虑数据通信方面和不可靠的数据传输方面的问题。  
>
> （2）功能  
>> 对一个进行的对话或连接提供可靠的传输服务，在通向网络的单一物理连接上实现该连接的复用，在单一连接上提供端到端的序号与流量控制、差错控制及恢复等服务。  
>
>（3）通信的主体  
>> 网络通信的主体是应用进程。  
>>> 进程是程序在计算机上的一次执行活动，是操作系统进行资源分配的单位。  
>>
>
>（4）端到端的通信    
>> 传输层为相互通信的应用进程提供了逻辑通信。  
>> 传输层的一个很重要的功能就是复用和分用。  
>
> （5）端口  
>> 操作系统中进程标识符（PID）不能用来标识端口。（一是因为操作系统可能不同，二是因为有些进程不需要进行网络通信）  
>> 为了使运行不同操作系统的计算机的应用进程能够互相通信，必须用统一的方法对TCP/IP体系的应用进程进行标识  
>> 解决方法：在运输层使用端口号（protocol portnumber），通常简称为端口（port）。  
>> 用16位标识； 只具有本地意义  
>> `客户—服务器通信方式时，必须先知道对方服务器的  IP地址和端口号`  
>> 端口种类  
>>> 服务器端：  
>>>> 熟知端口，数值一般为0~1023  
>>>> ![image2](https://github.com/onshero/PCN/blob/picture/熟知端口.png)  
>>>
>>> 客户端： 
>>>> 临时端口号，数值为1024~65535，留给客户进程选择暂时使用。通信结束后，这个端口号可供其他客户进程以后使用  
>>> 
>>
> 

### 传输层协议  
> TCP/IP的运输层有两个不同的协议：用户数据报协议UDP（User Datagram Protocol）和传输控制协议TCP（Transmission Control Protocol）  
> UDP协议  
>> （1）特点  
>>> 是无连接的  
>>> 尽最大努力交付，不保证可靠，不使用拥塞控制  
>>> 是面向报文的。应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文  
>>> 支持一对一、一对多、多对一和多对多的交互通信  
>>> UDP的首部开销小，只有8个字节  
>>
>> （2）数据格式  
>>> ![image3](https://github.com/onshero/PCN/blob/picture/UDP的数据格式.png)  
>>> 首部格式  
>>>> ![image4](https://github.com/onshero/PCN/blob/picture/UDP的首部格式.png)  
>>>
>>> 用户数据报UDP有两个字段：数据字段和首部字段。首部字段有8个字节，由4个字段组成，每个字段都是两个字节  
>>> 伪首部是为计算校验和而临时添加的12字节，并不参与传输  
>>
>> UDP是一种基于端口的分用和复用的通信方式  
>
> TCP协议  
>> （1）特点  
>>> 面向字节流  
>>> 面向连接的（每条连接只能有两个端点，只能是点对点的）  
>>> 提供全双工通信  
>>> 提供可靠交付的服务（确认机制、流量控制、拥塞控制）  
>>
>> 连接表示——套接字（socket）  
>>> socket = （IP地址：端口号）  
>>> 每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：  
>>>> TCP连接：= {socket1，socket2} = {（IP1：port1），（IP2，port2）}  
>>
>> （2）TCP报文段的首部格式  
>>> ![image5](https://github.com/onshero/PCN/blob/picture/TCP的首部格式.png)  
>>> **源端口和目的端口字段**——各占2字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。  
>>> **序号字段**——占4字节。TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。  
>>> **确认号字段**——占4字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。  
>>> **数据偏移（即首部长度）**——占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。以4字节为计算单位。  
>>> **保留字段**——占6位，保留为今后使用，但目前应置为0。  
>>> **六个标志位**  
>>>> 紧急URG——当URG为1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）。  
>>>> 确认ACK——只有当ACK为1时确认号字段才有效；为0时确认号无效。  
>>>> 推送PSH（Push）——收到PSH=1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。  
>>>> 复位RST（Reset）——当RST为1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。  
>>>> 同步SYN——SYN=1表示这是一个连接请求或连接接受报文。  
>>>> 终止FIN（Finish）——用来释放一个连接。FIN为1表明此报文段的发送端的数据已经发送完毕，并要求释放运输连接。  
>>>
>>> **窗口字段**——占2字节，用来让对方设置发送窗口的依据，单位为字节。  
>>> **检验和字段**——占2字节。检验和字段检验的范围包括首部和数据两部分。在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。  
>>> **紧急指针字段**——占16位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。  
>>> **选项字段**——长度可变。TCP最初只规定了一种选项，即最大报文段长度MISS。  
>>> **填充字段**——这是为了使整个首部长度是4字节的整数倍。  
>>
>
> UDP和TCP的对比  

| UDP 无连接服务 |  TCP 面向连接的服务 |
|  ------  |  ----  |
|不需要建立连接  |需要建立连接   |
|不需要接收方确认  |需要接收方确认   |
|不可靠传输  |可靠传输    |
|开销小  |开销大    |

### TCP可靠传输的工作原理  
> 理想条件下：  
>> 信道不产生差错  
>> 速度总能匹配  
>
> 实际情况中：  
>> 出现差错——比特错、丢包——重传  
>> 速度不匹配——丢包、拥塞——减速  
>
#### 停止等待协议ARQ（Automatic Repeat reQuest）  
> 基本原理：每发送完一个分组就停止，等待对方确认。  
> 必须  
>> 必须暂时保留已发送的分组的副本  
>> 分组和确认分组都必须进行编号  
>> 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些  
>>
> 可能遇到的情况（A为发送方，B为接收方）  
>> 无差错发生  
>>> A发送分组，B接收并返回确认信息，A接收到确认后继续发送分组，以此类推，直到所有数据发送和确认完毕  
>>
>> 超时重传  
>>> A发送的分组在互联网转发过程中未到达B，产生丢包现象，因此B也不会发送确认。所以A每发送一个分组都会设一个计时器，在等待时间上限值内未接收到B的确认，那么就要进行重传，重新设置计时器，知道在等待时间内收到B的确认才会发送下一个分组。如果重传到一定次数，那么就会报错，放弃这次通信  
>>
>> 确认丢失  
>>> A的分组正确到达了B，但B的确认在传输过程中丢失。因为A在等待时间内未收到确认，因此会产生超时重传，B就收到了相同的报文，因为报文携带相同的序号，所以重传的报文就不接收，然后再次发送确认  
>>
>> 确认迟到  
>>> B的确认因路径选择的原因虽未丢失但也未在A的等待时间内到达A，所以A会进行超时重传，最后A会收到重复的确认，B也会收到重复的报文，B只接收第一次收到的报文，而确认分组携带有相同确认号，所以A会收到迟到的确认到什么也不做  
>>
>
> 这种可靠传输协议常称为自动重传请求ARQ。  
> ARQ表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组  
#### 连续ARQ协议  
> ![image6](https://github.com/onshero/PCN/blob/picture/%E8%BF%9E%E7%BB%ADARQ.png)  
> 信道利用率U  
>> `U=T<sub>D</sub>/(T<sub>D</sub>+RTT+T<sub>A</sub>)`  
>> T<sub>D</sub>：有效分组发送时间  
>> RTT：往返时间  
>> T<sub>A</sub>：确认分组发送时间  
>
> 连续ARQ协议：提高信道利用率——流水线传输  
>> 发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认  
>> 串行——>并行  
>> 全双工工作模式  
>> ![image7](https://github.com/onshero/PCN/blob/picture/ARQ%E7%89%B9%E7%82%B9.png)  
>> （1）发送窗口：可连续发送而不需要等待确认的分组数  
>> （2）累计确认：接收方不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已到达  
>>> 优点：容易实现，即使确认丢失也不必重传  
>>> 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。—— go-back-N  
>>
>> （3）Go-back-N （回退N）：表示需要再退回来重传已发送过的N个分组  
>>> 如果发送方发送了前5个分组，而中间第3个分组丢失。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面三个分组再重传一次。  
>>> 可见当通信线路好时，效率是大大提升的；当通信线路质量不好时，连续ARQ协议会带来负面的影响  
>>
>
> TCP可靠通信的具体实现  
>> 关键要解决：  
>>> 窗口大小的动态确定；以字节为单位的滑动窗口  
>>>> 发送方窗口受到接收方窗口的制约；TCP标准强烈不赞成发送窗口前沿向后收缩  
>>>> ![image8](https://github.com/onshero/PCN/blob/picture/%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A31.png)  
>>>> ![image9](https://github.com/onshero/PCN/blob/picture/%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A32.png)  
>>>> ![image10](https://github.com/onshero/PCN/blob/picture/%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A33.png)  
>>>> ![image11](https://github.com/onshero/PCN/blob/picture/%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A34.png)  
>>>> ![image12](https://github.com/onshero/PCN/blob/picture/%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A35.png)  
>>>> 发送缓存和接收缓存的作用  
>>>>> 发送缓存用来暂时存放：发送应用程序传送给发送方TCP准备发送的数据；TCP已经发送但尚未受到确认的数据  
>>>>> 接收缓存用来暂时存放：按序到达的、但尚未被接收应用程序读取的数据；未按序到达的数据  
>>>>
>>>> 发送窗口的确认：数据报分装格式中有一个窗口字段，发送数据分组和确认分组时都会携带着窗口字段，该字段中就可以写入发送方的窗口能力和接收方的窗口能力。发送窗口就根据接收窗口来定义  
>>>> **注意**  
>>>>> 发送窗口并不是总是等于接收窗口（在流量控制和拥塞控制时会进行调节）  
>>>>> 未按序到达的数据，先临时存放在接收窗口中  
>>>>> 累计确认  
>>>>
>>>
>>> 确定合理的重传时间  
>

#### 重传时间的选择  
> 太短——>建投不必要的重传——>网络负荷大  
> 太长——>空闲时间增大——>效率减低  
> TCP采用了一种自适应的算法：  
>> 记录报文段发出时间T1   
>> 记录相应确认到达时间T2
>> 计算加权平均往返时间RTTs  
>> 计算超时重传时间RTO  
>
> （1）计算加权平均往返时间RTTs  
>> 加权平均往返时间又称为平滑的往返时间  
>> RTT= T2-T1  
>> 第一次测量到RTT样本时，RTTs值就取为所测量到的RTT样本值。以后每测量到一个新的RTT样本，就按下式重新计算一次RTTs  
>> `新的RTTs = (1-α)x(旧的RTTs) + α x (新的RTT样本)`  
>> 其中，0< α ≤1。若α很接近于0，表示RTT值更新较慢；若很接近于1，表示RTT值更新较快  
>> RFC 2988 推荐的α值为1/8，即0.125  
>> 更看重历史的值，避免了某次突发情况对其造成很大的影响  
>
> （2）计算超时重传时间RTO  
>> RTO应略大于上面得出的加权平均往返时间RTTS  
>> RFC 2988 建议使用下式计算RTO：  
>> `RTO=RTTs + 4xRTT<sub>D</sub>`  
>> RTT<sub>D</sub>是RTT的偏差的加权平均值  
>> RFC 2988 建议这样计算RTTD。第一次测量时，RTTD值取为测量到的RTT样本值的一半。在以后的测量中，则使用下式计算加权平均的RTTD：  
>> `新的RTT<sub>D</sub>=（1-β）x （旧的RTT<sub>D</sub>）+ β x |RTTs-新的RTT样本|`  
>> β是个小于1的系数，其推荐值是1/4，即0.25  
>
> 发送重传后往返时间的测量（报文段1未收到确认，重传报文段2后，收到了确认报文段ACK）  
>> 解决方法1：Karn算法  
>>> 在计算平均往返时间RTTS时，只要报文段重传了，就不采用其往返时间样本  
>>> 这样得出的加权平均往返时间RTTS和超时重传时间RTO比较准确  
>>> 但当重传比例变大时，超时重传时间需要更新  
>>
>> 解决方法2：修正的Karn算法（实践证明，该策略较为合理）  
>>> 报文段每重传一次，就把RTO增大一些：`新的RTO = γ x (旧的RTO)`    
>>> 系数γ的典型值是2  
>>> 当不再发生报文段的重传时，才睡根据上述步骤更新RTO  
>>
>
### TCP的流量控制（flow control）  
> 流量控制就是让发送方的发送频率不要太快，既要让接收方来得及接受，也不要使网络发生拥塞  
> 利用滑动窗口的机制可以很方便地在TCP连接上实现流量控制  
> 接收方通过改变接收窗口“rwnd”来控制发送方的发送窗口  
> 零窗口问题：  
>> TCP为每一个连接设有一个持续计时器  
>> 只要TCP连接的一方受到对方的零窗口通知，就启动持续计时器  
>> 若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值  
>> 若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器  
>> 若窗口不是零，则死锁的僵局就可以打破了  
>
> 流量控制就是通过根据接收方能力来调节发送方的发送速度，以使双方的速度达到匹配协调  

### TCP的拥塞控制  
> 在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞  
> 出现拥塞的条件：对资源需求的总和 > 可用资源    
> 若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降  
> 流量控制是解决两端问题，拥塞控制是解决全局问题  
> `拥塞控制`要防止过多的数据注入到网络中。是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素  
> `流量控制`往往指在给定的发送端和接收端之间的点对点通信量的控制，所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收  
> ![image13]()  
> 一般原理  
>> 开环控制  
>>> 就是在设计网络时事先将有关发送拥塞的因素考虑周到，力求网络在工作时不产生拥塞。系统一旦运行，就不再中途进行改进了。  
>> 
>> 闭环控制  
>>> 基于反馈环路的概念；  
>>> 监测网络以便检测到拥塞在何时、何处发生；  
>>> 将拥塞发生的信息传送到可采取行动的地方；  
>>> 调整网络系统的运行以解决出现的问题。  
>>
>
> 慢开始和拥塞避免  
>> 发送方维持一个叫做拥塞窗口 cwnd（congestion window） 的状态变量  
>> 拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的窗口等于拥塞窗口。如再考虑接收方的接收能力，则发送窗口还可能小于拥塞窗口。Min{rwnd,cwnd}  
>> 只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。  
>> 但只要网络出现拥塞，拥塞窗口就减小一些，以便注入到网络中的分组数。  
>> 
>> 慢开始算法  
>>> 原理  
>>>> 在主机刚开始发送报文段时可先设置拥塞窗口cwnd=1，即设置为一个最大报文段MSS的数值  
>>>> 在每收到一个对新的报文段的确认后，将拥塞窗口加1，即增加一个MSS的数值  
>>>> 用这样的方法逐步增大发送端的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理  
>>>
>>> 传输轮次  
>>>> 使用慢开始算法后，每经过一个传输轮次，拥塞窗口cwnd就加倍  
>>>> “传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并对已发送的最后一个字节的确认  
>>>
>>
>> 拥塞避免算法  
>>> 思路是让拥塞窗口缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口加1，而不是加倍，使拥塞窗口按线性规律缓慢增长。  
>>> 设置慢开始门限状态变量ssthresh  
>>>> 慢开始门限ssthresh的用法如下：  
>>>>> 当cwnd < ssthresh时，使用慢开始算法  
>>>>> 当cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法  
>>>>> 当cwnd = ssthresh时，即可使用慢开始算法也可使用拥塞避免算法  
>>>>
>>>
>>> 当出现拥塞时  
>>>> 无论是慢开始阶段还是拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限ssthresh设置为出现拥塞时发送窗口值的一半（但不能小于2）  
>>>> 然后把拥塞窗口cwnd重新设置为1，重新开始执行慢开始算法  
>>>> 目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕  
>>>
>>
>> 特点
>>> 加法增大
>>>> 指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞  
>>>
>>> 乘法减小  
>>>> 只要出现一次网络拥塞，就把慢开始门限值ssthresh设置为当前的拥塞窗口的一半  
>>>> 当网络频繁出现拥塞时，ssthresh值就下降得很快，以大大减少注入到网络中的分组数  
>>>
>>
>> **注意**
>>> “拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞，并非指完全能够避免了拥塞   
>>
>
> 其他拥塞控制方法  
>> 快重传和快恢复  
>>> 尽早重传未被确认的报文段（连续3个重复确认）  
>>> 乘法减小——ssthresh减半  
>>> cwnd从ssthresh减半后的值开始执行拥塞避免算法（加法增大）  
>>
>> 随即早期检测RED  
>>> 在拥塞发生前判断  
>>> 按一定概率丢弃排队的数据报文段  
>>
>

### TCP的链接管理 
> 运输连接就有三个阶段，即：连接建立、数据传送和连接释放。  
> 运输连接的管理就是使运输链接的建立和释放都能正常地进行。  
> 连接建立过程中要解决以下三个问题：  
>> 要使每一方都能确知对方的存在  
>> 要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）  
>> 能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配。  
>
> 客户服务器方式  
>> TCP连接的建立都是采用客户服务器方式  
>> 主动发起连接建立的应用进程叫做客户  
>> 被动等待连接建立的应用进程叫做服务器  
> 
> 用三次握手建立TCP连接，也就是往返三个信息  
> TCP的连接建立（A为客户，B为服务器）  
>> ![image14]()  
>> A的TCP向V发出连接请求报文段，其首部中的同步位SYN=1，选择序号seq=x，表明传送数据时的第一个数据字节的序号是x  
>> B的TCP收到连接请求报文段后，如同意，则发回确认。B在确认报文段中应使SYN=1,ACK=1,其确认号ack=x+1,自己选择的序号seq=y  
>> A收到此报文段后向B给出确认，其ACK=1,确认号ack=y+1。A的TCP通知上层应用进程，连接已建立  
>> B的TCP收到主机A的确认后，也通知其上层应用进程：TCP连接已经建立  
>
> TCP的连接释放（四次挥手）  
>> ![image15]()  
>> 数据传输结束后，通信的双方都可释放连接。现在A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的FIN=1,其序号seq=u,等待B的确认  
>> B发出确认，确认号ack=u+1，而这个报文段自己的序号seq=v。TCP服务器进程通知高层应用进程。从A到B这个方向的连接就释放了，TCP连接处于半关闭状态。B若发送数据，A仍要接收  
>> 若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。连接释放报文段的首部FIN=1，ACK=1，自己的序号seq=w,ack=u+1  
>> A收到连接释放报文段后，必须发出确认。在确认报文段中ACK=1，确认号ack=w+1，自己的序号seq=u+1  
>> 
>> TCP连接必须经过时间2MSL(Maximum Segment Lifetime)后才能真正释放掉  
>
> TCP的有限状态机  
>> ![image16]()  
>> TCP有限状态机的图中每一个方框都是TCP可能具有的状态  
>> 每个方框中的大写英文字符串都是TCP标准所使用的TCP连接状态名。状态之间的箭头表示可能发生的状态变迁  
>> 箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作  
>> 图中有三种不同的箭头  
>>> 粗实线箭头表示对客户进程的正常变迁  
>>> 粗虚线箭头表示对服务器进程的正常变迁  
>>> 另一种细线箭头表示异常变迁  
>>
>
