### 传输层定义与功能  
> ![image1](https://github.com/onshero/PCN/blob/picture/传输层.png)  
> （1）定义  
>> Transport Layer也称为运输层。在OSI中，传输层利用网络层提供的服务，并通过传输层地址提供给高层用户传输数据的通信端口，使系统间高层资源的共享不必考虑数据通信方面和不可靠的数据传输方面的问题。  
>
> （2）功能  
>> 对一个进行的对话或连接提供可靠的传输服务，在通向网络的单一物理连接上实现该连接的复用，在单一连接上提供端到端的序号与流量控制、差错控制及恢复等服务。  
>
>（3）通信的主体  
>> 网络通信的主体是应用进程。  
>>> 进程是程序在计算机上的一次执行活动，是操作系统进行资源分配的单位。  
>>
>
>（4）端到端的通信    
>> 传输层为相互通信的应用进程提供了逻辑通信。  
>> 传输层的一个很重要的功能就是复用和分用。  
>
> （5）端口  
>> 操作系统中进程标识符（PID）不能用来标识端口。（一是因为操作系统可能不同，二是因为有些进程不需要进行网络通信）  
>> 为了使运行不同操作系统的计算机的应用进程能够互相通信，必须用统一的方法对TCP/IP体系的应用进程进行标识  
>> 解决方法：在运输层使用端口号（protocol portnumber），通常简称为端口（port）。  
>> 用16位标识； 只具有本地意义  
>> `客户—服务器通信方式时，必须先知道对方服务器的  IP地址和端口号`  
>> 端口种类  
>>> 服务器端：  
>>>> 熟知端口，数值一般为0~1023  
>>>> ![image2](https://github.com/onshero/PCN/blob/picture/熟知端口.png)  
>>>
>>> 客户端： 
>>>> 临时端口号，数值为1024~65535，留给客户进程选择暂时使用。通信结束后，这个端口号可供其他客户进程以后使用  
>>> 
>>
> 

### 传输层协议  
> TCP/IP的运输层有两个不同的协议：用户数据报协议UDP（User Datagram Protocol）和传输控制协议TCP（Transmission Control Protocol）  
> UDP协议  
>> （1）特点  
>>> 是无连接的  
>>> 尽最大努力交付，不保证可靠，不使用拥塞控制  
>>> 是面向报文的。应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文  
>>> 支持一对一、一对多、多对一和多对多的交互通信  
>>> UDP的首部开销小，只有8个字节  
>>
>> （2）数据格式  
>>> ![image3](https://github.com/onshero/PCN/blob/picture/UDP的数据格式.png)  
>>> 首部格式  
>>>> ![image4](https://github.com/onshero/PCN/blob/picture/UDP的首部格式.png)  
>>>
>>> 用户数据报UDP有两个字段：数据字段和首部字段。首部字段有8个字节，由4个字段组成，每个字段都是两个字节  
>>> 伪首部是为计算校验和而临时添加的12字节，并不参与传输  
>>
>> UDP是一种基于端口的分用和复用的通信方式  
>
> TCP协议  
>> （1）特点  
>>> 面向字节流  
>>> 面向连接的（每条连接只能有两个端点，只能是点对点的）  
>>> 提供全双工通信  
>>> 提供可靠交付的服务（确认机制、流量控制、拥塞控制）  
>>
>> 连接表示——套接字（socket）  
>>> socket = （IP地址：端口号）  
>>> 每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：  
>>>> TCP连接：= {socket1，socket2} = {（IP1：port1），（IP2，port2）}  
>>
>> （2）TCP报文段的首部格式  
>>> ![image5](https://github.com/onshero/PCN/blob/picture/TCP的首部格式.png)  
>>> **源端口和目的端口字段**——各占2字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。  
>>> **序号字段**——占4字节。TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。  
>>> **确认号字段**——占4字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。  
>>> **数据偏移（即首部长度）**——占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。以4字节为计算单位。  
>>> **保留字段**——占6位，保留为今后使用，但目前应置为0。  
>>> **六个标志位**  
>>>> 紧急URG——当URG为1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）。  
>>>> 确认ACK——只有当ACK为1时确认号字段才有效；为0时确认号无效。  
>>>> 推送PSH（Push）——收到PSH=1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。  
>>>> 复位RST（Reset）——当RST为1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。  
>>>> 同步SYN——SYN=1表示这是一个连接请求或连接接受报文。  
>>>> 终止FIN（Finish）——用来释放一个连接。FIN为1表明此报文段的发送端的数据已经发送完毕，并要求释放运输连接。  
>>>
>>> **窗口字段**——占2字节，用来让对方设置发送窗口的依据，单位为字节。  
>>> **检验和字段**——占2字节。检验和字段检验的范围包括首部和数据两部分。在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。  
>>> **紧急指针字段**——占16位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。  
>>> **选项字段**——长度可变。TCP最初只规定了一种选项，即最大报文段长度MISS。  
>>> **填充字段**——这是为了使整个首部长度是4字节的整数倍。  
>>
>
> UDP和TCP的对比  

| UDP 无连接服务 |  TCP 面向连接的服务 |
|  ------  |  ----  |
|不需要建立连接  |需要建立连接   |
|不需要接收方确认  |需要接收方确认   |
|不可靠传输  |可靠传输    |
|开销小  |开销大    |

### TCP可靠传输的工作原理  
> 理想条件下：  
>> 信道不产生差错  
>> 速度总能匹配  
>
> 实际情况中：  
>> 出现差错——比特错、丢包——重传  
>> 速度不匹配——丢包、拥塞——减速  
>
#### 停止等待协议ARQ（Automatic Repeat reQuest）  
> 基本原理：每发送完一个分组就停止，等待对方确认。  
> 必须  
>> 必须暂时保留已发送的分组的副本  
>> 分组和确认分组都必须进行编号  
>> 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些  
>>
> 可能遇到的情况（A为发送方，B为接收方）  
>> 无差错发生  
>>> A发送分组，B接收并返回确认信息，A接收到确认后继续发送分组，以此类推，直到所有数据发送和确认完毕  
>>
>> 超时重传  
>>> A发送的分组在互联网转发过程中未到达B，产生丢包现象，因此B也不会发送确认。所以A每发送一个分组都会设一个计时器，在等待时间上限值内未接收到B的确认，那么就要进行重传，重新设置计时器，知道在等待时间内收到B的确认才会发送下一个分组。如果重传到一定次数，那么就会报错，放弃这次通信  
>>
>> 确认丢失  
>>> A的分组正确到达了B，但B的确认在传输过程中丢失。因为A在等待时间内未收到确认，因此会产生超时重传，B就收到了相同的报文，因为报文携带相同的序号，所以重传的报文就不接收，然后再次发送确认  
>>
>> 确认迟到  
>>> B的确认因路径选择的原因虽未丢失但也未在A的等待时间内到达A，所以A会进行超时重传，最后A会收到重复的确认，B也会收到重复的报文，B只接收第一次收到的报文，而确认分组携带有相同确认号，所以A会收到迟到的确认到什么也不做  
>>
>
> 这种可靠传输协议常称为自动重传请求ARQ。  
> ARQ表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组  
#### 连续ARQ协议  
> ![image6]()  
> 信道利用率U  
>> `U=T<sub>D</sub>/(T<sub>D</sub>+RTT+T<sub>A</sub>)`
>> T<sub>D</sub>：有效分组发送时间  
>> RTT：往返时间  
>> T<sub>A</sub>：确认分组发送时间  
>
> 连续ARQ协议：提高信道利用率——流水线传输  
>> 发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认  
>> 串行——>并行  
>> 全双工工作模式  
>> ![image7]()  
>> （1）发送窗口：可连续发送而不需要等待确认的分组数  
>> （2）累计确认：接收方不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已到达  
>>> 优点：容易实现，即使确认丢失也不必重传  
>>> 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。—— go-back-N  
>>
>> （3）Go-back-N （回退N）：表示需要再退回来重传已发送过的N个分组  
>>> 如果发送方发送了前5个分组，而中间第3个分组丢失。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面三个分组再重传一次。  
>>> 可见当通信线路好时，效率是大大提升的；当通信线路质量不好时，连续ARQ协议会带来负面的影响  
>>
>
> TCP可靠通信的具体实现  
>> 关键要解决：  
>>> 窗口大小的动态确定；以字节为单位的滑动窗口  
>>>> 发送方窗口受到接收方窗口的制约；TCP标准强烈不赞成发送窗口前沿向后收缩  
>>>> ![image8]()  
>>>> ![image9]()  
>>>> ![image10]()  
>>>> ![image11]()  
>>>> ![image12]()  
>>>> 发送缓存和接收缓存的作用  
>>>>> 发送缓存用来暂时存放：发送应用程序传送给发送方TCP准备发送的数据；TCP已经发送但尚未受到确认的数据  
>>>>> 接收缓存用来暂时存放：按序到达的、但尚未被接收应用程序读取的数据；未按序到达的数据  
>>>>
>>>> 发送窗口的确认：数据报分装格式中有一个窗口字段，发送数据分组和确认分组时都会携带着窗口字段，该字段中就可以写入发送方的窗口能力和接收方的窗口能力。发送窗口就根据接收窗口来定义  
>>>> **注意**  
>>>>> 发送窗口并不是总是等于接收窗口（在流量控制和拥塞控制时会进行调节）  
>>>>> 未按序到达的数据，先临时存放在接收窗口中  
>>>>> 累计确认  
>>>>
>>>
>>> 确定合理的重传时间  
>

#### 重传时间的选择  
> 太短——>建投不必要的重传——>网络负荷大  
> 太长——>空闲时间增大——>效率减低  
> TCP采用了一种自适应的算法：  
>> 记录报文段发出时间T1   
>> 记录相应确认到达时间T2
>> 计算加权平均往返时间RTTs  
>> 计算超时重传时间RTO  
>
> （1）计算加权平均往返时间RTTs  
>> 加权平均往返时间又称为平滑的往返时间  
>> RTT= T2-T1  
>> 第一次测量到RTT样本时，RTTs值就取为所测量到的RTT样本值。以后每测量到一个新的RTT样本，就按下式重新计算一次RTTs  
>> `新的RTTs = (1-α)x(旧的RTTs) + α x (新的RTT样本)`  
>> 其中，0< α ≤1。若α很接近于0，表示RTT值更新较慢；若很接近于1，表示RTT值更新较快  
>> RFC 2988 推荐的α值为1/8，即0.125  
>> 更看重历史的值，避免了某次突发情况对其造成很大的影响  
>
> （2）计算超时重传时间RTO  
>> RTO应略大于上面得出的加权平均往返时间RTTS  
>> RFC 2988 建议使用下式计算RTO：  
>> `RTO=RTTs + 4xRTT<sub>D</sub>`  
>> RTT<sub>D</sub>是RTT的偏差的加权平均值  
>> RFC 2988 建议这样计算RTTD。第一次测量时，RTTD值取为测量到的RTT样本值的一半。在以后的测量中，则使用下式计算加权平均的RTTD：  
>> `新的RTT<sub>D</sub>=（1-β）x （旧的RTT<sub>D</sub>）+ β x |RTTs-新的RTT样本|`  
>> β是个小于1的系数，其推荐值是1/4，即0.25  
>
> 发送重传后往返时间的测量（报文段1未收到确认，重传报文段2后，收到了确认报文段ACK）  
>> 解决方法1：Karn算法  
>>> 在计算平均往返时间RTTS时，只要报文段重传了，就不采用其往返时间样本  
>>> 这样得出的加权平均往返时间RTTS和超时重传时间RTO比较准确  
>>> 但当重传比例变大时，超时重传时间需要更新  
>>
>> 解决方法2：修正的Karn算法（实践证明，该策略较为合理）  
>>> 报文段每重传一次，就把RTO增大一些：`新的RTO = γ x (旧的RTO)`    
>>> 系数γ的典型值是2  
>>> 当不再发生报文段的重传时，才睡根据上述步骤更新RTO  
>>
>
### TCP的流量控制  
### TCP的拥塞控制  
### TCP的链接管理  
